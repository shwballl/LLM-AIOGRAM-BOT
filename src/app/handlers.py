import html
import re

from aiogram import F, Router
from aiogram.filters import CommandStart
from aiogram.types import Message

from .ai import generate_response
from .keyboards import reply_kb


router = Router()

@router.message(CommandStart())
async def command_start_handler(message: Message) -> None:
    """Handle the start command. Greets the user and provides a keyboard with available commands."""
    
    await message.answer(f"Hello, {html.bold(message.from_user.full_name)}! I'am a Chat GPT Clone Bot. You can ask me anything!", reply_markup=reply_kb)


@router.message(F.text == "Help")
async def hi(message: Message) -> None:
    """Responds to the 'Help' command with a message explaining the bot's capabilities."""

    await message.answer(f"This bot can answer your question! Just ask me and i will help you!")

@router.message(F.text == "Start chat")
async def hi(message: Message) -> None:
    """Responds to the 'Start chat' command with a greeting and a question about how the bot can assist the user."""

    await message.answer(f"Hello! 👋 How can I assist you today?")


def format_text_for_html(response: str) -> list[str]:
    """Formats a response string for HTML display in a messaging application.

    This function processes the input `response` to identify code blocks and regular text. 
    Code blocks are wrapped in `<pre>` tags with HTML escaping for safe display. Non-code 
    text is collected into chunks, and each chunk is limited to Telegram's character limit 
    for messages (4096 characters). Large blocks are split into smaller chunks if necessary.

    Args:
        response (str): The response string containing text and possibly code blocks 
                        enclosed in triple backticks.

    Returns:
        list[str]: A list of strings, each formatted for HTML display, with code blocks 
                   properly wrapped and text chunks respecting the character limit.
    """

    chunks = []
    buffer = ""

    parts = re.split(r"(```.*?```)", response, flags=re.DOTALL)
    for part in parts:
        if part.startswith("```") and part.endswith("```"):
            code = part.strip("`")
            lang_and_code = code.split("\n", 1)
            if len(lang_and_code) == 2:
                _, code_content = lang_and_code
            else:
                code_content = lang_and_code[0]
            if buffer:
                chunks.append(buffer.strip())
                buffer = ""
            chunks.append(f"<pre>{html.escape(code_content)}</pre>")
        else:
            buffer += part

    if buffer:
        chunks.append(buffer.strip())

    # Telegram limit = 4096 characters per message
    result = []
    for chunk in chunks:
        if len(chunk) <= 4096:
            result.append(chunk)
        else:
            # Hard split for very large blocks
            for i in range(0, len(chunk), 4000):
                result.append(chunk[i:i+4000])
    return result

@router.message()
async def echo(message: Message):
    """Responds to any message with a response generated by the AI model.

    This handler is the main entry point for the AI model. It processes the message text,
    generates a response with the AI model, formats the response for display in a
    messaging application, and sends the response back to the user.

    The response is formatted for HTML display in a messaging application. The function
    splits the response into chunks if it exceeds Telegram's character limit for messages.
    """
    loading_message = await message.answer("⏳ Typing...", parse_mode="HTML")

    response = generate_response(message.text)
    chunks = format_text_for_html(response)

    await loading_message.delete()
    for chunk in chunks:
        await message.answer(chunk, parse_mode="HTML")

